<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on zhuyie&#39;s blog</title>
    <link>https://zhuyie.github.io/posts/</link>
    <description>Recent content in Posts on zhuyie&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© zhuyie</copyright>
    <lastBuildDate>Mon, 19 Apr 2021 21:20:23 +0800</lastBuildDate><atom:link href="https://zhuyie.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在MacOS命令行程序中使用Metal</title>
      <link>https://zhuyie.github.io/posts/use-metal-in-command-line-app/</link>
      <pubDate>Mon, 19 Apr 2021 21:20:23 +0800</pubDate>
      
      <guid>https://zhuyie.github.io/posts/use-metal-in-command-line-app/</guid>
      <description>出错 最近在试验用GPU做计算，由于日常工作在MacBook Pro上，很自然想要试下Apple的Metal API。
官方有个示例程序Performing Calculations on a GPU，很容易懂。下载示例代码到本地构建运行，完全正常。这么简单的吗？
那就开始用到自己的程序中吧！因为要与CPU/OpenCL等版本进行横行对比，很自然的Metal版本也使用了command line app的形式。代码写完编译很顺利，试跑一下，结果不对。。。
作为老程序员，遇到这种事情很淡定。即使是测试用的小程序，我也加上了错误处理相关的代码（良好的编程素养！），那看一下错误输出，查一下文档，一般都能搞定。
出错的代码位置是：
MTLCompileOptions* compileOptions = [MTLCompileOptions new]; id&amp;lt;MTLLibrary&amp;gt; lib = [device newLibraryWithSource:source options:compileOptions error:&amp;amp;error]; if (lib == nil) { NSLog(@&amp;#34;Failed to create library: %@.&amp;#34;, error); return nil; } 而对应的错误输出为：
2021-04-19 22:00:10.546 estimate_pi_metal[3334:87426] Failed to create library: (null). 也就是：newLibraryWithSource执行失败返回了nil，与此同时error也为null。
官方文档 newLibraryWithSource官方文档上对Return Value的说明：
A new library object that contains the compiled source code or nil if an error occurred. 对error参数的说明：</description>
    </item>
    
    <item>
      <title>VC2019 std::generate_canonical 性能问题</title>
      <link>https://zhuyie.github.io/posts/cpp-generate-canonical-perf/</link>
      <pubDate>Mon, 19 Apr 2021 11:07:20 +0800</pubDate>
      
      <guid>https://zhuyie.github.io/posts/cpp-generate-canonical-perf/</guid>
      <description>起因 最近一个项目中需要生成一堆均匀分布的伪随机浮点数。在C++11中，随机数生成算法以及相关的工具函数进行了不小的扩充。对于我的需求，常规的实现方法是：
#include &amp;lt;random&amp;gt;#include &amp;lt;iostream&amp;gt;int main() { std::random_device rd; std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()  std::uniform_real_distribution&amp;lt;float&amp;gt; dis(1.0f, 2.0f); for (int n = 0; n &amp;lt; 10; ++n) { // Use dis to transform the random unsigned int generated by gen into a  // float in [1, 2). Each call to dis(gen) generates a new random float  std::cout &amp;lt;&amp;lt; dis(gen) &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; return 0; } 其输出类似于：</description>
    </item>
    
  </channel>
</rss>
