<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>VC2019 std::generate_canonical 性能问题 - zhuyie&#39;s blog</title><meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:image" content=""/>
	<meta property="og:title" content="VC2019 std::generate_canonical 性能问题" />
<meta property="og:description" content="偶然发现std::generate_canonical在不同平台上可能存在巨大的性能差异。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuyie.github.io/posts/cpp-generate-canonical-perf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-19T11:07:20&#43;08:00" />
<meta property="article:modified_time" content="2021-04-19T11:07:20&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="VC2019 std::generate_canonical 性能问题"/>
<meta name="twitter:description" content="偶然发现std::generate_canonical在不同平台上可能存在巨大的性能差异。"/>
<script src="https://zhuyie.github.io/js/feather.min.js"></script>
	
	<link href="https://zhuyie.github.io/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="https://zhuyie.github.io/css/main.css" />
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://zhuyie.github.io/">zhuyie&#39;s blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">VC2019 std::generate_canonical 性能问题</h1>
			<div class="meta">Posted on Apr 19, 2021</div>
		</div>
		

		<section class="body">
			<h2 id="起因">起因</h2>
<p>最近一个项目中需要生成一堆均匀分布的伪随机浮点数。在C++11中，随机数生成算法以及相关的工具函数进行了不小的扩充。对于我的需求，常规的实现方法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    std<span style="color:#f92672">::</span>random_device rd;
    std<span style="color:#f92672">::</span>mt19937 gen(rd()); <span style="color:#75715e">// Standard mersenne_twister_engine seeded with rd()
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>uniform_real_distribution<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> dis(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">2.0f</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>n) {
        <span style="color:#75715e">// Use dis to transform the random unsigned int generated by gen into a 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// float in [1, 2). Each call to dis(gen) generates a new random float
</span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> dis(gen) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
    }
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>其输出类似于：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">1.80829 1.15391 1.18483 1.38969 1.36094 1.0648 1.97798 1.27984 1.68261 1.57326
</code></pre></div><p>哇，几行代码就可以实现一个高质量的均匀分布-伪随机-浮点数生成器，C++ NB !</p>
<p>然而，在进行性能测试时发现，MacOS版和Windows版存在巨大的性能差异（Windows下慢很多）。经过初步分析，运行耗时主要的差异点在uniform_real_distribution::operator()中，接下来细致分析一下。</p>
<h2 id="uniform_real_distributionoperator的具体实现">uniform_real_distribution::operator()的具体实现</h2>
<p>MacOS, XCode 12.0.1 (12A7300) :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_RealType</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_URNG</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span>
<span style="color:#66d9ef">typename</span> uniform_real_distribution<span style="color:#f92672">&lt;</span>_RealType<span style="color:#f92672">&gt;::</span>result_type
uniform_real_distribution<span style="color:#f92672">&lt;</span>_RealType<span style="color:#f92672">&gt;::</span><span style="color:#66d9ef">operator</span>()(_URNG<span style="color:#f92672">&amp;</span> __g, <span style="color:#66d9ef">const</span> param_type<span style="color:#f92672">&amp;</span> __p)
{
    <span style="color:#66d9ef">return</span> (__p.b() <span style="color:#f92672">-</span> __p.a())
        <span style="color:#f92672">*</span> _VSTD<span style="color:#f92672">::</span>generate_canonical<span style="color:#f92672">&lt;</span>_RealType, numeric_limits<span style="color:#f92672">&lt;</span>_RealType<span style="color:#f92672">&gt;::</span>digits<span style="color:#f92672">&gt;</span>(__g)
        <span style="color:#f92672">+</span> __p.a();
}
</code></pre></div><p>Windows, VC2019 :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _NRAND(eng, resty) (_STD generate_canonical&lt;resty, static_cast&lt;size_t&gt;(-1)&gt;(eng))
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ty</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">uniform_real_distribution</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> uniform_real<span style="color:#f92672">&lt;</span>_Ty<span style="color:#f92672">&gt;</span> {
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ty</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">uniform_real</span> {
    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Engine</span><span style="color:#f92672">&gt;</span>
    _NODISCARD result_type <span style="color:#66d9ef">operator</span>()(_Engine<span style="color:#f92672">&amp;</span> _Eng, <span style="color:#66d9ef">const</span> param_type<span style="color:#f92672">&amp;</span> _Par0) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_Eval</span>(_Eng, _Par0);
    }
    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Engine</span><span style="color:#f92672">&gt;</span>
    result_type _Eval(_Engine<span style="color:#f92672">&amp;</span> _Eng, <span style="color:#66d9ef">const</span> param_type<span style="color:#f92672">&amp;</span> _Par0) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_NRAND</span>(_Eng, _Ty) <span style="color:#f92672">*</span> (_Par0._Max <span style="color:#f92672">-</span> _Par0._Min) <span style="color:#f92672">+</span> _Par0._Min;
    }
};
</code></pre></div><p>可以看到，逻辑很类似。其中__p.b()和__p.a()代表了此分布的上界和下界，对应实现就是返回一个运行期不变的_RealType值，因此可以认为主要耗时都在std::generate_cononical中。</p>
<h2 id="测试程序">测试程序</h2>
<p>准备一个小测试程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std<span style="color:#f92672">::</span>chrono;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000000</span>;
    std<span style="color:#f92672">::</span>mt19937 gen;
    <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">auto</span> start <span style="color:#f92672">=</span> system_clock<span style="color:#f92672">::</span>now();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">float</span> v <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>generate_canonical<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span>, std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;::</span>digits<span style="color:#f92672">&gt;</span>(gen);
        sum <span style="color:#f92672">+=</span> v;
    }
    <span style="color:#66d9ef">auto</span> duration <span style="color:#f92672">=</span> duration_cast<span style="color:#f92672">&lt;</span>microseconds<span style="color:#f92672">&gt;</span>(system_clock<span style="color:#f92672">::</span>now() <span style="color:#f92672">-</span> start);
    fprintf(stdout, <span style="color:#e6db74">&#34;sum = %f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, sum);
    fprintf(stdout, <span style="color:#e6db74">&#34;duration = %.2fms</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, duration.count()<span style="color:#f92672">/</span><span style="color:#ae81ff">1000.0</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>在我的MacBook Pro(16-inch, 2019)上测试，MacOS版本的输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">sum = 499981300.522139
duration = 4203.75ms
</code></pre></div><p>同一台机器上，Windows版本（VC2019）的输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">sum = 499981300.522139
duration = 34302.06ms
</code></pre></div><p><strong>Windows版要慢8倍左右</strong>。</p>
<h2 id="profiling">Profiling</h2>
<p>使用Instruments的Time Profiler抓取数据，可以看到MacOS版本的测试程序多数CPU时间消耗在std::generate_canonical函数中：
<img src="/images/cpp-generate-canonical-1.jpg" alt=""></p>
<p>具体到std::generate_canonical内部，主要分布在调用伪随机数生成器以及数学运算代码上，看起来比较正常：
<img src="/images/cpp-generate-canonical-2.jpg" alt=""></p>
<p>Windows上使用VTune抓取数据。可以看到绝大多数CPU时间都消耗在std::generate_canonical函数中，符合预期：
<img src="/images/cpp-generate-canonical-3.jpg" alt=""></p>
<p>但进到std::generate_canonical内部就有点奇怪了，<strong>超过80%的时间用在求值一个变量_Ceil</strong>，猜测这就是导致Windows版本明显慢的原因：
<img src="/images/cpp-generate-canonical-4.jpg" alt=""></p>
<h2 id="分析">分析</h2>
<p>对比Windows和MacOS下两份std::generate_canonical实现可知，Windows版中的_Ceil变量对应MacOS版中的__logR，都是用来确定后面的循环需要执行的次数。</p>
<p>Windows版中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Ceil <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(_STD ceil(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>_Real<span style="color:#f92672">&gt;</span>(_Minbits) <span style="color:#f92672">/</span> _STD log2(_Rx)));
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Kx   <span style="color:#f92672">=</span> _Ceil <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> _Ceil;
</code></pre></div><p>其中std::log2和std::ceil是标准库中的两个普通函数，因此会有两次function call的运行开销。</p>
<p>而在MacOS版中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> size_t __logR <span style="color:#f92672">=</span> __log2<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint64_t</span>, _URNG<span style="color:#f92672">::</span>max() <span style="color:#f92672">-</span> _URNG<span style="color:#f92672">::</span>min() <span style="color:#f92672">+</span> <span style="color:#66d9ef">uint64_t</span>(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">&gt;::</span>value;
<span style="color:#66d9ef">const</span> size_t __k <span style="color:#f92672">=</span> __b <span style="color:#f92672">/</span> __logR <span style="color:#f92672">+</span> (__b <span style="color:#f92672">%</span> __logR <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> (__b <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</code></pre></div><p>在我们的测试程序中，此处的_URNG是std::mt19937，其max()为0xFFFFFFFF，min()为0，因此上面__log2模版的第二个参数为0x100000000。</p>
<p>继续看__log2模版类的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> _Xp, size_t _Rp<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__log2_imp</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> size_t value <span style="color:#f92672">=</span> _Xp <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> _Rp) <span style="color:#f92672">?</span> _Rp
                                           : __log2_imp<span style="color:#f92672">&lt;</span>_Xp, _Rp <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;::</span>value;
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> _Xp<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__log2_imp</span><span style="color:#f92672">&lt;</span>_Xp, <span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> size_t value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t _Rp<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__log2_imp</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>, _Rp<span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> size_t value <span style="color:#f92672">=</span> _Rp <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_UIntType</span>, _UIntType _Xp<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__log2</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> size_t value <span style="color:#f92672">=</span> __log2_imp<span style="color:#f92672">&lt;</span>_Xp,
                                    <span style="color:#66d9ef">sizeof</span>(_UIntType) <span style="color:#f92672">*</span> __CHAR_BIT__ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;::</span>value;
};
</code></pre></div><p>哇，还是蛮精巧的，通过模版元编程的方式在<strong>编译期</strong>计算出了_Xp（在我们的例子中为0x100000000）的log2值，当然这里假设了_Xp仅会有一个bit为1。</p>
<h2 id="结论">结论</h2>
<ul>
<li>MacOS下std::generate_canonical的实现采用了模版元编程的方式进行优化，通过编译期求值的方式，使得调用伪随机数生成器之外的其它额外开销非常小。</li>
<li>反观VC2019中的对应实现，使用了两个通用函数std::log2和std::ceil，带来了较大的额外开销，在密集调用的场景下性能很差。</li>
</ul>

		</section>

		<div class="post-tags">
			
			
			
		</div>
	</article>
</main>
<footer>
<hr><a class="soc" href="https://github.com/zhuyie" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2021  © zhuyie |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script>
      feather.replace()
</script></div>
    </body>
</html>
