<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zhuyie&#39;s blog</title>
    <link>https://zhuyie.github.io/</link>
    <description>Recent content on zhuyie&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© zhuyie</copyright>
    <lastBuildDate>Tue, 18 May 2021 11:26:35 +0800</lastBuildDate><atom:link href="https://zhuyie.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一个测试CPU分支预测的示例程序</title>
      <link>https://zhuyie.github.io/posts/cpu-branch-prediction-demo/</link>
      <pubDate>Tue, 18 May 2021 11:26:35 +0800</pubDate>
      
      <guid>https://zhuyie.github.io/posts/cpu-branch-prediction-demo/</guid>
      <description>起因 最近在看一些CPU Microarchitecture相关的资料。其中的分支预测器1，虽然知道概念，但其对性能的影响程度没有清晰的概念。因此，设计了一个小测试程序2。
Test program #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;random&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;chrono&amp;gt;using namespace std::chrono; static int dummy[2]; int main(int argc, char* argv[]) { // parsing command line  bool sort = false; if (argc &amp;gt; 1 &amp;amp;&amp;amp; strcmp(argv[1], &amp;#34;1&amp;#34;) == 0) { sort = true; } // prepare test data (uniformly distributed random values)  const int arraySize = 5000; std::vector&amp;lt;int&amp;gt; data; data.resize(arraySize); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution&amp;lt;&amp;gt; dis(0, 256); for (int i = 0; i &amp;lt; arraySize; i++) { data[i] = dis(gen); } // sort or not  if (sort) { std::sort(data.</description>
    </item>
    
    <item>
      <title>CPU Cache False Sharing</title>
      <link>https://zhuyie.github.io/posts/cpu-cache-false-sharing/</link>
      <pubDate>Mon, 03 May 2021 13:06:16 +0800</pubDate>
      
      <guid>https://zhuyie.github.io/posts/cpu-cache-false-sharing/</guid>
      <description>起因 一个通过蒙特卡洛方法估算 π 值的测试程序，采用了多线程的方式，其代码大致如下：
#include &amp;#34;...&amp;#34; class RandomNumber { mt19937 mt19937_; // random number generator  const float MT19937_FLOAT_MULTI = 2.3283064365386962890625e-10f; // (2^32-1)^-1 public: void seed(unsigned int seed) { mt19937_.seed(seed); } float operator() () { return mt19937_() * MT19937_FLOAT_MULTI; } }; void worker(int worker_id, int64_t samples, RandomNumber *rnd, int64_t *in) { rnd-&amp;gt;seed(worker_id); // seed the prng  for (int64_t i = 0; i &amp;lt; samples; i++) { float x = (*rnd)(); float y = (*rnd)(); if (x*x + y*y &amp;lt;= 1) { (*in)++; } } } int main(int argc, char* argv[]) { int num_threads = 16; int64_t num_samples = 1000000000; // parsing command line arguments  auto start = system_clock::now(); RandomNumber* rnd = new RandomNumber[num_threads]; int64_t* in_points = new int64_t[num_threads]; int64_t total_points = num_samples; int64_t circle_points = 0; vector&amp;lt;thread&amp;gt; threads; for (int i = 0; i &amp;lt; num_threads; i++) { int64_t samples = num_samples / num_threads; if (i == num_threads - 1) { samples += num_samples - samples * num_threads; } threads.</description>
    </item>
    
    <item>
      <title>在MacOS命令行程序中使用Metal</title>
      <link>https://zhuyie.github.io/posts/use-metal-in-command-line-app/</link>
      <pubDate>Mon, 19 Apr 2021 21:20:23 +0800</pubDate>
      
      <guid>https://zhuyie.github.io/posts/use-metal-in-command-line-app/</guid>
      <description>出错 最近在试验用GPU做计算，由于日常工作在MacBook Pro上，很自然想要试下Apple的Metal API。
官方有个示例程序Performing Calculations on a GPU，很容易懂。下载示例代码到本地构建运行，完全正常。这么简单的吗？
那就开始用到自己的程序中吧！因为要与CPU/OpenCL等版本进行横向对比，很自然的Metal版本也使用了command line app的形式。代码写完编译很顺利，试跑一下，结果不对。。。
作为老程序员，遇到这种事情很淡定。即使是测试用的小程序，我也加上了错误处理相关的代码（良好的编程素养！），那看一下错误输出，查一下文档，一般都能搞定。
出错的代码位置是：
MTLCompileOptions* compileOptions = [MTLCompileOptions new]; id&amp;lt;MTLLibrary&amp;gt; lib = [device newLibraryWithSource:source options:compileOptions error:&amp;amp;error]; if (lib == nil) { NSLog(@&amp;#34;Failed to create library: %@.&amp;#34;, error); return nil; } 而对应的错误输出为：
2021-04-19 22:00:10.546 estimate_pi_metal[3334:87426] Failed to create library: (null). 也就是：newLibraryWithSource执行失败返回了nil，与此同时error也为null。
官方文档 newLibraryWithSource官方文档上对Return Value的说明：
A new library object that contains the compiled source code or nil if an error occurred. 对error参数的说明：</description>
    </item>
    
    <item>
      <title>VC2019 std::generate_canonical 性能问题</title>
      <link>https://zhuyie.github.io/posts/cpp-generate-canonical-perf/</link>
      <pubDate>Mon, 19 Apr 2021 11:07:20 +0800</pubDate>
      
      <guid>https://zhuyie.github.io/posts/cpp-generate-canonical-perf/</guid>
      <description>起因 最近一个项目中需要生成一堆均匀分布的伪随机浮点数。在C++11中，随机数生成算法以及相关的工具函数进行了不小的扩充。对于我的需求，常规的实现方法是：
#include &amp;lt;random&amp;gt;#include &amp;lt;iostream&amp;gt;int main() { std::random_device rd; std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()  std::uniform_real_distribution&amp;lt;float&amp;gt; dis(1.0f, 2.0f); for (int n = 0; n &amp;lt; 10; ++n) { // Use dis to transform the random unsigned int generated by gen into a  // float in [1, 2). Each call to dis(gen) generates a new random float  std::cout &amp;lt;&amp;lt; dis(gen) &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; return 0; } 其输出类似于：</description>
    </item>
    
  </channel>
</rss>
